import os, uuid, json, pytz, math
from datetime import datetime, timezone, timedelta

from sqlalchemy.orm import declarative_base
from sqlalchemy import select


import helper
import settings as C


engino = helper.getEngine_Local()
Base = declarative_base()
Base.metadata.reflect(engino)


class Consultation(Base):
    __table__ = Base.metadata.tables['base_consultation']


class Domaine(Base):
    __table__ = Base.metadata.tables['base_domaine']


class Categorie(Base):
    __table__ = Base.metadata.tables['base_categorie']


class Qualification(Base):
    __table__ = Base.metadata.tables['base_qualification']


class Agrement(Base):
    __table__ = Base.metadata.tables['base_agrement']


class Lot(Base):
    __table__ = Base.metadata.tables['base_lot']


class ConsultationDomaine(Base):
    __table__ = Base.metadata.tables['base_consultation_domaine']


class LotQualification(Base):
    __table__ = Base.metadata.tables['base_lot_qualification']


class LotAgrement(Base):
    __table__ = Base.metadata.tables['base_lot_agrement']


class Acheteur(Base):
    __table__ = Base.metadata.tables['base_acheteur']


class Type(Base):
    __table__ = Base.metadata.tables['base_type']


class Procedure(Base):
    __table__ = Base.metadata.tables['base_procedure']


class ConUpdate(Base):
    __table__ = Base.metadata.tables['base_con_update']


class Mode(Base):
    __table__ = Base.metadata.tables['base_mode']


class Reglage(Base):
    __table__ = Base.metadata.tables['base_reglage']


class ProfileFavCon(Base):
    __table__ = Base.metadata.tables['base_profile_fav_con']


def updateUpdateTime(session):
    illacha = 0
    try:
        clu = session.scalars(select(Reglage)).first()
        if clu == None:
            clu = Reglage(id=uuid.uuid4(), cons_last_update=datetime.now(timezone.utc))
            session.add(clu)
        else:
            clu.cons_last_update = datetime.now(timezone.utc)
        session.commit()
        helper.printMessage('DEBUG', 'worker', 'Updated updated time.')
    except Exception as x:
        helper.printMessage('ERROR', 'dbaser.updateUpdateTime', f'Exception raised when updating metadata in database: {str(x)}')
        illacha = 1
    return illacha


def consExists(session, portal_id):
    """
    # Synopsis:
        Check if a Consultation exists on database.
    # Params:
        session: database session to use.
        portal_id: Id of the Consultation to check.
    # Return:
        None or a Consultation instance.
    """
    return session.scalars(select(Consultation).where(Consultation.portal_id == portal_id)).first()
    # return e


def writeData(dicto, session):
    """
    # Synopsis:
        Makes database objects from data and save these objects to database.
        This function only saves an object to datatbese if that object does not exist.
    # Params:
        dicto: Objects dictionary instance, as generated by getObject() function from objeer.py.
        session: database session to use to save data to.
    # Return:
        integer: 0 if no errors were reported, non-zero otherwise.
    """

    total_esti, total_caut = 0, 0
    l_requires_qua, l_requires_agr, l_requires_ech, l_has_reu, l_has_vis = None, None, None, None, None,
    total_qua, total_agr, total_ech, total_reu, total_vis = 0, 0, 0, 0, 0

    # Check if Consultation already exists.
    # helper.printMessage('DEBUG', 'dbaser.writeData', f'>>>>>>>>>>>>>>> dbaser.writeData XXXXXXXXXXXXXXX')
    # helper.printMessage('DEBUG', 'dbaser.writeData', f"dicto = { str(dicto) }")
    # helper.printMessage('DEBUG', 'dbaser.writeData', f'XXXXXXXXXXXXXXX dbaser.writeData <<<<<<<<<<<<<<<')
    p_id = dicto[C.IDENTI]
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Saving data Objects for id {p_id} ... ')
    if session.query(Consultation.portal_id).filter_by(portal_id=p_id).first():
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Consultation with id {p_id} already exists.')
        return 0

    # Acheteur
    nom = dicto[C.ACHETE]
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Creating Acheteur: {nom[:C.TRUNCA]}... ')
    if len(nom) < 3:
        helper.printMessage('ERROR', 'dbaser.writeData', f'=== Acheteur name too short: {nom[:C.TRUNCA]}...')
        return 1
    acheteur = session.scalars(select(Acheteur).where(Acheteur.nom == nom)).first()
    if acheteur:
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Acheteur already exists: {nom[:C.TRUNCA]}...')
    else:
        acheteur = Acheteur(id=uuid.uuid4(), nom=nom)
        session.add(acheteur)
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Created Acheteur: {nom[:C.TRUNCA]}...')

    # Mode of Awarding
    nom = dicto[C.MODEPA]
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Creating Mode: {nom} ... ')
    if len(nom) < 3:
        helper.printMessage('ERROR', 'dbaser.writeData', f'=== Mode name too short: {nom[:C.TRUNCA]}...')
        return 1
    mode = session.scalars(select(Mode).where(Mode.nom == nom)).first()
    if mode:
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Mode already exists: {nom[:C.TRUNCA]}...')
    else:
        mode = Mode(id=uuid.uuid4(), nom=nom)
        session.add(mode)
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Created Mode: {nom[:C.TRUNCA]}...')

    # Procedure
    nom = dicto[C.PROCED]
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Creating Procedure: {nom} ... ')
    if len(nom) < 3:
        helper.printMessage('ERROR', 'dbaser.writeData', f'=== Procedure name too short: {nom[:C.TRUNCA]}...')
        return 1
    procedure = session.scalars(select(Procedure).where(Procedure.nom == nom)).first()
    if procedure:
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Procedure already exists: {nom[:C.TRUNCA]}...')
    else:
        procedure = Procedure(id=uuid.uuid4(), nom=nom)
        session.add(procedure)
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Created Procedure: {nom[:C.TRUNCA]}...')

    # Category
    nom = dicto[C.CATEGC]
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Creating Categorie: {nom} ... ')
    if len(nom) < 3:
        helper.printMessage('ERROR', 'dbaser.writeData', f'=== Categorie name too short: {nom[:C.TRUNCA]}...')
        return 1
    categorie = session.scalars(select(Categorie).where(Categorie.nom == nom)).first()
    if categorie:
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Categorie already exists: {nom[:C.TRUNCA]}...')
    else:
        categorie = Categorie(id=uuid.uuid4(), nom=nom)
        session.add(categorie)
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Created Categorie: {nom[:C.TRUNCA]}...')

    # Type
    nom = dicto[C.TYPEAN]
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Creating Type: {nom} ... ')
    if len(nom) < 3:
        helper.printMessage('ERROR', 'dbaser.writeData', f'=== Type name too short: {nom[:C.TRUNCA]}...')
        return 1
    typecon = session.scalars(select(Type).where(Type.nom == nom)).first()
    if typecon:
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Type already exists: {nom[:C.TRUNCA]}...')
    else:
        typecon = Type(id=uuid.uuid4(), nom=nom)
        session.add(typecon)
        helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Created Type: {nom[:C.TRUNCA]}...')

    # Domains of Activity
    domaines = []
    helper.printMessage('DEBUG', 'dbaser.writeData', 'Creating Domains of activity ... ')
    for dom in dicto[C.DOMAIN]:
        # nom = e.get('nom').strip()
        helper.printMessage('DEBUG', 'dbaser.writeData', f'Creating Domain: {nom[:C.TRUNCA]}... ')
        if len(dom) > 2:
            domaine = session.scalars(select(Domaine).where(Domaine.nom == dom)).first()
            if domaine:
                helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Domain already exists: {dom[:C.TRUNCA]}...')
            else:
                domaine = Domaine(id=uuid.uuid4(), nom=dom)
                session.add(domaine)
                helper.printMessage('DEBUG', 'dbaser.writeData', f'=== Created Domain: {dom[:C.TRUNCA]}...')
            domaines.append(domaine)
        else:
            helper.printMessage('ERROR', 'dbaser.writeData', f'=== Domain name too short: {dom[:C.TRUNCA]}...')

    cons_repec = ''
    match dicto[C.REPONS]:  # Look at the image ...
        case "reponse-elec-oblig": cons_repec = 'RO'
        case "reponse-elec": cons_repec = 'OO'
        case "reponse-elec-oblig-avec-signature": cons_repec = 'RR'
        case "reponse-elec-avec-signature": cons_repec = 'OR'
        case "reponse-elec-non": cons_repec = 'I'


    # # Sanitizing deadline date and time
    
    # # Step 1: Parse the datetime string (assume this is what you saw on the clock)
    # naive_date_limite_depot = helper.getDateTime(dicto[C.DDLINE]) if dicto[C.DDLINE] != None else None
    # # Step 2: Localize to Casablanca timezone
    # casa_tz = pytz.timezone("Africa/Casablanca")
    # localized_date_limite_depot = casa_tz.localize(naive_date_limite_depot)
    # # Step 3 (optional but recommended): Convert to UTC
    # utc_date_limite_depot = localized_date_limite_depot.astimezone(pytz.UTC)
    
    utc_date_limite_depot = helper.reading2LocalTime(dicto[C.DDLINE])


    # Consultation
    consultation = Consultation(
        id=uuid.uuid4(),
        active=True,
        date_publication=helper.getDateTime(dicto[C.PUDATE]) if dicto[C.PUDATE] != None else None,
        # date_limite_depot=helper.getDateTime(dicto[C.DDLINE]) if dicto[C.DDLINE] != None else None,
        date_limite_depot=utc_date_limite_depot,
        cancelled = dicto[C.CANCEL],
        reference=dicto[C.REFERE],
        categorie=categorie.id,
        nombre_lots=int(dicto[C.NUMBLO]),
        objet=dicto[C.OBJETC],
        lieu_execution=dicto[C.LIEUEX],
        acheteur_public=acheteur.id,
        type_annonce=typecon.id,
        procedure_annonce=procedure.id,
        mode_passation=mode.id,
        reponse_electronique=cons_repec,
        prix_acquisition_plans=helper.money2Float(dicto[C.PRIXPL]),
        retrait_dossiers_adresse=dicto[C.RETDOS],
        depot_offres_adresse=dicto[C.DEPOFF],
        ouverture_plis_adresse=dicto[C.LIEOUV],
        contact_nom=dicto[C.CONTNM],
        contact_email=dicto[C.CONTML],
        contact_tel=dicto[C.CONTTL],
        contact_fax=dicto[C.CONTFX],
        portal_id=p_id,
        portal_link=dicto[C.LINKKK],
        portal_size = dicto[C.DCESIZ],
        size_bytes = dicto[C.BYTESS],
        created_on=datetime.now(timezone.utc),
    )

    # Lots Objects
    lots = []
    helper.printMessage('DEBUG', 'dbaser.writeData', 'Creating Consultation Lots (one or more) ... ')
    if dicto[C.LOTSSS]:
        lots_count = len(dicto[C.LOTSSS])
        for i, l in enumerate(dicto[C.LOTSSS], start=1):
            helper.printMessage('DEBUG', 'dbaser.writeData', f'Handling Lot {i} / {lots_count} ... ')

            # Lot Category
            helper.printMessage('DEBUG', 'dbaser.writeData', 'Creating Lot Category ... ')
            categorielot = session.scalars(select(Categorie).where(Categorie.nom == l[C.CATEGL])).first()
            if categorielot == None:
                nom = l[C.CATEGL]
                if len(nom) > 2:
                    categorielot = Categorie(id=uuid.uuid4(), nom=l[C.CATEGL])
                    session.add(categorielot)
                    helper.printMessage('DEBUG', 'dbaser.writeData', f'Created Lot Category: {nom[:C.TRUNCA]}...')
                else:
                    helper.printMessage('ERROR', 'dbaser.writeData', f'Lot Category name too short: {nom[:C.TRUNCA]}...')
                    return 1
            else:
                helper.printMessage('DEBUG', 'dbaser.writeData', 'Lot Category already exists.')

            # Lot Qualifications
            qualifs = []
            helper.printMessage('DEBUG', 'dbaser.writeData', 'Creating Lot Qualifications ... ')
            qualifs_count = len(l[C.QUALIF])
            if qualifs_count > 0:
                for j, q in enumerate(l[C.QUALIF], start=1):
                    helper.printMessage('DEBUG', 'dbaser.writeData', f'Handling Lot Qualification {j} / {qualifs_count} ... ')
                    if len(q) > 2:
                        qualif = session.scalars(select(Qualification).where(Qualification.nom == q)).first()
                        if qualif == None:
                            qualif = Qualification(id=uuid.uuid4(), nom=q)
                            session.add(qualif)
                            helper.printMessage('DEBUG', 'dbaser.writeData', f'Created Lot Qualification : {q[:C.TRUNCA]}...')
                        else:
                            helper.printMessage('DEBUG', 'dbaser.writeData', f'Lot Qualification already exists : {q[:C.TRUNCA]}...')
                        qualifs.append(qualif)
                    else:
                        helper.printMessage('ERROR', 'dbaser.writeData', f'Lot Qualification name too short: {q[:C.TRUNCA]}...')
            else:
                helper.printMessage('DEBUG', 'dbaser.writeData', '=== Lot has no Qualifications.')

            # Lot Agrements
            agrements = []
            helper.printMessage('DEBUG', 'dbaser.writeData', 'Creating Lot Agrements ... ')
            agrems_count = len(l[C.AGREME])
            if agrems_count > 0:
                for n, a in enumerate(l[C.AGREME], start=1):
                    helper.printMessage('DEBUG', 'dbaser.writeData', f'Handling Lot Agrements {n} / {agrems_count} ... ')
                    if len(a) > 2:
                        agrement = session.scalars(select(Agrement).where(Agrement.nom == a)).first()
                        if agrement == None:
                            agrement = Agrement(id=uuid.uuid4(), nom=a)
                            session.add(agrement)
                            helper.printMessage('DEBUG', 'dbaser.writeData', f'Created Lot Agrement : {a[:C.TRUNCA]}...')
                        else:
                            helper.printMessage('DEBUG', 'dbaser.writeData', f'Lot Agrement already exists : {a[:C.TRUNCA]}...')
                        agrements.append(agrement)
                    else:
                        helper.printMessage('ERROR', 'dbaser.writeData', f'Lot Agrement name too short: {a[:C.TRUNCA]}...')
            else:
                helper.printMessage('DEBUG', 'dbaser.writeData', '=== Lot has no Agrements.')

            l_echantis = l[C.ECHANT]
            for e in l_echantis: 
                e[C.RVDATE] = helper.getDateTime(e[C.RVDATE]) if len(e[C.RVDATE]) > 2 else None
                if e[C.RVDATE] != None: e[C.RVDATE] = e[C.RVDATE].isoformat()

            l_reunions = l[C.REUNIO]
            for r in l_reunions: 
                r[C.RVDATE] = helper.getDateTime(r[C.RVDATE]) if len(r[C.RVDATE]) > 2 else None
                if r[C.RVDATE] != None: r[C.RVDATE] = r[C.RVDATE].isoformat()

            l_visites = l[C.VISITS]
            for v in l_visites: 
                v[C.RVDATE] = helper.getDateTime(v[C.RVDATE]) if len(v[C.RVDATE]) > 2 else None
                if v[C.RVDATE] != None: v[C.RVDATE] = v[C.RVDATE].isoformat()

            # Lot
            lot = Lot(
                id=uuid.uuid4(),
                lot_number=l[C.LOTNMB],  #
                consultation=consultation.id,
                objet=l[C.OBJETL],
                categorie=categorielot.id,
                description=l[C.DESCRI],
                estimation=helper.money2Float(l[C.ESTIMA]),
                caution_provisoire=helper.money2Float(l[C.CAUTIO]),
                reserve_pme=True if l[C.RESPME].lower() == 'oui' else False,
                echantillons = l_echantis,
                reunions = l_reunions,
                visites = l_visites,
                variante=l[C.VARIAN],
            )
            session.add(lot)
            lots.append(lot)
            total_esti += lot.estimation
            total_caut += lot.caution_provisoire

            # Agrements and Qualifications relation tables
            for a in agrements: session.add(LotAgrement(id=uuid.uuid4(), agrement_id=a.id, lot_id=lot.id))
            for q in qualifs: session.add(LotQualification(id=uuid.uuid4(), qualification_id=q.id, lot_id=lot.id))
            
            total_agr += len(agrements)
            total_qua += len(qualifs)
            total_ech += len(l_echantis)
            total_reu += len(l_reunions)
            total_vis += len(l_visites)
            

            helper.printMessage('DEBUG', 'dbaser.writeData', f'Created Lot: {lot.objet[:C.TRUNCA]}...')
    else:
        helper.printMessage('ERROR', 'dbaser.writeData', f'Dictionary had no Lots !')
        
    # Update consultation with Lot data
    consultation.total_estimation   = total_esti
    consultation.caution_provisoire = total_caut
    consultation.requires_qua       = total_qua > 0
    consultation.requires_agr       = total_agr > 0
    consultation.requires_ech       = total_ech > 0
    consultation.has_reu            = total_reu > 0
    consultation.has_vis            = total_vis > 0
    
    session.add(consultation)
    helper.printMessage('DEBUG', 'dbaser.writeData', f'Created Consultation: {consultation.objet[:C.TRUNCA]}...')

    # Consultation domains relations
    for f in domaines: session.add(ConsultationDomaine(id=uuid.uuid4(), consultation_id=consultation.id, domaine_id=f.id))

    # Commit changes
    try:
        session.commit()
        helper.printMessage('DEBUG', 'dbaser.writeData', 'Objects successfully saved to database.')
        return 0
    except Exception as x:
        helper.printMessage('ERROR', 'dbaser.writeData', f'Exception while saving objects to database: {str(x)}.')
        return 1

    return 1


# def getDCEbytes(consino):
#     """
#     Calculates the actual file size on disk
#     """
#     dce_folder = os.path.join(C.MEDIA_ROOT, f'dce/{C.DL_PATH_PREFIX}{consino.portal_id}')
#     total_size = 0
#     try:
#         if not os.path.exists(dce_folder):
#             raise FileNotFoundError(f"The folder '{dce_folder}' does not exist.")

#         for entry in os.scandir(dce_folder):
#             if entry.is_file():
#                 try:
#                     total_size += entry.stat().st_size
#                 except (PermissionError, FileNotFoundError) as e:
#                     print(f"Error accessing file {entry.path}: {e}")
#         return total_size

#     except Exception as e:
#         print(f"Error processing folder {dce_folder}: {e}")
#         return 0

def logConUpdate(session, consino, updated_field, update_digest=None):
    try:
        helper.printMessage('DEBUG', 'dbaser.logConUpdate', f'Logging item update for id = {consino.portal_id}')
        con_update = ConUpdate(
            consultation = consino.portal_id,
            updated_field = updated_field,
            update_digest = update_digest,
        )
        session.add(con_update)
        session.commit()
        helper.printMessage('DEBUG', 'dbaser.logConUpdate', f'Successfully logged item update for id = {consino.portal_id}')
    except Exception as xc:
        helper.printMessage('ERROR', 'dbaser.logConUpdate', f'Failed logging item update for id = {consino.portal_id}: {str(xc)} ')



def hasChanged(dicto, consino, session):
    """
    # Synopsis:
        Compares data from dicto with consino object.
    # Params:
        dicto: Objects dictionary instance, as generated by getObject() function from objeer.py.
        consino: Consultation instance.
    # Return:
        None if not mtching, integer: 0 if no difference was found or 1 if a difference was found.
    """
    
    if consino == None: return 0
    if dicto[C.IDENTI] != consino.portal_id: return 0
    helper.printMessage('DEBUG', 'dbaser.hasChanged', f'Checking DB for changes: id = {consino.portal_id} ... ')
    
    if dicto[C.DCESIZ] == None:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: DCE size from portal was empty.')
        logConUpdate(consino, 'DCE size', 'DCE size from portal was empty')        
        return 1

    deadline_date_dc = helper.reading2LocalTime(dicto[C.DDLINE])
    if deadline_date_dc != consino.date_limite_depot:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Deadline: {deadline_date_dc} vs {consino.date_limite_depot}')
        logConUpdate(consino, 'Deadline', f'{deadline_date_dc} vs {consino.date_limite_depot}')
        return 1

    if dicto[C.DCESIZ] != consino.portal_size:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: DCE size: {dicto[C.DCESIZ]} vs {consino.portal_size}')
        logConUpdate(consino, 'DCE size', f'{dicto[C.DCESIZ]} vs {consino.portal_size}')
        return 1

    if dicto[C.CANCEL] != consino.cancelled:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Item cancellation status: {dicto[C.CANCEL]} vs {consino.cancelled}')
        logConUpdate(consino, 'Status', f'{dicto[C.CANCEL]} vs {consino.cancelled}')
        return 1

    pub_date_dc = helper.getDateTime(dicto[C.PUDATE]).date()
    if pub_date_dc != consino.date_publication:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Publication date: {pub_date_dc} vs {consino.date_publication}')
        logConUpdate(consino, 'Publication date', f'{pub_date_dc} vs {consino.date_publication}')
        return 1

    if dicto[C.REFERE] != consino.reference:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Reference: {dicto[C.REFERE]} vs {consino.reference}')
        logConUpdate(consino, 'Reference', f'{dicto[C.REFERE]} vs {consino.reference}')
        return 1

    if int(dicto[C.NUMBLO]) != consino.nombre_lots:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Number of lots: {int(dicto[C.NUMBLO])} vs {consino.nombre_lots}')
        logConUpdate(consino, 'Number of lots', f'{int(dicto[C.NUMBLO])} vs {consino.nombre_lots}')
        return 1

    if dicto[C.OBJETC] != consino.objet:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Object: {dicto[C.OBJETC]} vs {consino.objet}')
        logConUpdate(consino, 'Object', f'{dicto[C.OBJETC]} vs {consino.objet}')
        return 1

    if dicto[C.LIEUEX] != consino.lieu_execution:
        helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Execution location: {dicto[C.LIEUEX]} vs {consino.lieu_execution}')
        logConUpdate(consino, 'Execution location', f'{dicto[C.LIEUEX]} vs {consino.lieu_execution}')
        return 1


    lots_dc = dicto[C.LOTSSS]

    if lots_dc :
        lots_db = session.scalars(select(Lot).where(Lot.consultation == consino.id)).all()
        # lots_db = consino.lots.all()
        if len(lots_db) != len(lots_dc):
            helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Number of lots: {len(lots_dc)} vs {len(lots_dc)}')
            logConUpdate(consino, 'Number of lots', f'{len(lots_dc)} vs {len(lots_dc)}')
            return 1
        
        total_esti_db, total_caut_db, total_esti_dc, total_caut_dc = 0, 0, 0, 0
        for l in lots_dc:
            total_esti_dc += helper.money2Float(l[C.ESTIMA])
            total_caut_dc += helper.money2Float(l[C.CAUTIO])
        for l in lots_db:
            total_esti_db += l.estimation
            total_caut_db += l.caution_provisoire
        if round(float(total_esti_dc), 1) != round(float(total_esti_db), 1) :
            helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Total estimate: {float(total_esti_dc)} vs {float(total_esti_db)}')
            logConUpdate(consino, 'Total estimate', f'{float(total_esti_dc)} vs {float(total_esti_db)}')
            return 1
        if round(float(total_caut_dc), 1) != round(float(total_caut_db), 1) :
            helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Total caution: {float(total_caut_dc)} vs {float(total_caut_db)}')
            logConUpdate(consino, 'Total caution', f'{float(total_caut_dc)} vs {float(total_caut_db)}')
            return 1
        

    if dicto[C.BYTESS] != 0:
        localBytes = consino.size_bytes
        if localBytes != 0:
            if dicto[C.BYTESS] != localBytes:
                helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== Change found: Files bytes: {dicto[C.BYTESS]} vs {localBytes}')
                logConUpdate(consino, 'Files bytes', f'{dicto[C.BYTESS]} vs {localBytes}')
                return 1

    helper.printMessage('DEBUG', 'dbaser.hasChanged', f'=== No changes were found in checked fields.')
    return 0


def deleteCons(portal_id, session):
    e = session.scalars(select(Consultation).where(Consultation.portal_id == portal_id)).first()
    if not e: return 1

    cds = session.scalars(select(ConsultationDomaine).where(ConsultationDomaine.consultation_id == e.id)).all()
    for cd in cds : session.delete(cd)

    lots = session.scalars(select(Lot).where(Lot.consultation == e.id)).all()
    for l in lots:
        las = session.scalars(select(LotAgrement).where(LotAgrement.lot_id == l.id)).all()
        for la in las: session.delete(la)
        lqs = session.scalars(select(LotQualification).where(LotQualification.lot_id == l.id)).all()
        for lq in lqs: session.delete(lq)
        session.delete(l)
    session.delete(e)

    try:
        session.commit()
        helper.printMessage('DEBUG', 'dbaser.deleteCons', 'Consultation and related objects deleted successfully.')
        return 0
    except Exception as xc:
        helper.printMessage('Error', 'dbaser.deleteCons', str(xc))
    return 1


def getObsoleteDce(session, age=30):
    
    target_date = datetime.now() - timedelta(days=age)
    query_stmt = select(Consultation).where(Consultation.date_limite_depot < target_date)
    return session.scalars(query_stmt).all()


def getCurrentCons(session, age=15):
    
    target_date = datetime.now() - timedelta(days=age)
    query_stmt = select(Consultation).where(Consultation.date_limite_depot > target_date)
    return session.scalars(query_stmt).all()
    
    